---
layout: single
title:  "[ìë£Œêµ¬ì¡°ìŠ¤í„°ë””] ë¦¬ìŠ¤íŠ¸"
categories: coding
tag: [python, blog, jekyll]
toc: true
author_profile: false
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>

# ë¦¬ìŠ¤íŠ¸(LIST)
: ë°ì´í„°ë¥¼ ìˆœì„œëŒ€ë¡œ ë‚˜ì—´í•´ ë†“ì€ ìë£Œ êµ¬ì¡°

## ì„ í˜•êµ¬ì¡°ë¥¼ ê°–ëŠ” ë¦¬ìŠ¤íŠ¸
1. ì„ í˜• ë¦¬ìŠ¤íŠ¸(Linear List)
- ë°ì´í„°ê°€ ë°°ì—´ì²˜ëŸ¼ ì—°ì†í•˜ëŠ”(linear) ë©”ëª¨ë¦¬ ê³µê°„ì— ì €ì¥ë˜ì–´ ìˆœì„œë¥¼ ê°–ëŠ”ë‹¤.
2. ì—°ê²° ë¦¬ìŠ¤íŠ¸(Linked List)
- ë°ì´í„°ê°€ ë©”ëª¨ë¦¬ ê³µê°„ì— ì—°ì†ì ìœ¼ë¡œ ì –ì•„ë˜ì–´ ìˆì§€ ì•Šë”ë¼ë„ ê°ê°ì˜ ë°ì´í„° ì•ˆì— ë‹¤ìŒ ë°ì´í„°ì— ëŒ€í•œ ì •ë³´ë¥¼ ê°–ê³  ìˆì–´ ì„œë¡œ ì—°ê²°(Linked)ëœë‹¤.

### ë°°ì—´ë¡œ ì„ í˜• ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ì—ˆì„ ë•Œ ë¬¸ì œì 
1. ìŒ“ì´ëŠ” ë°ì´í„°ì˜ ìµœëŒ€ í¬ê¸°ë¥¼ ë¯¸ë¦¬ ì•Œì•„ì•¼ í•©ë‹ˆë‹¤.
2. ë°ì´í„°ë¥¼ ì‚½ì…, ì‚­ì œí•  ë•Œë§ˆë‹¤ ë§Œì€ ë°ì´í„°ë¥¼ ì˜®ê²¨ì•¼ í•˜ë¯€ë¡œ íš¨ìœ¨ì´ ì¢‹ì§€ ì•ŠìŠµë‹ˆë‹¤.


# í¬ì¸í„°ë¡œ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ë§Œë“¤ê¸°
: ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ëŠ” `í¬ì¸í„°`ë¥¼ ê° ë…¸ë“œì— í¬í•¨ì‹œí‚¤ëŠ” ì—°ê²° ë¦¬ìŠ¤íŠ¸

## í¬ì¸í„°ë¡œ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ë§Œë“¤ê¸°
ë°ì´í„° ì‚½ì… â¡ï¸ ë…¸ë“œìš© ê°ì²´ ìƒì„±
ë°ì´í„° ì‚­ì œ â¡ï¸ ë…¸ë“œìš© ê°ì²´ ì‚­ì œ
ğŸ” í¬ì¸í„°ë¡œ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ë©´ ë°°ì—´ë¡œ ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ ë•Œ ë°œìƒí•˜ëŠ” ë¬¸ì œ í•´ê²° ê°€ëŠ¥

* ë…¸ë“œ í´ë˜ìŠ¤
```java

class Node<E> {
    E data;         // ë°ì´í„°ë¥¼ ì°¸ì¡°
    Node<E> next;   // ë‹¤ìŒ ë…¸ë“œë¥¼ ì°¸ì¡°
}

```

* LinkedList class
```java
import java.util.Comparator;

public class LinkedList<E> {

    // ë…¸ë“œ
    class Node<E> {
        private E data;         // ë°ì´í„°
        private Node<E> next;   // ë’¤ìª½ í¬ì¸í„°(ë‹¤ìŒ ë…¸ë“œ ì°¸ì¡°)

        // ìƒì„±ì
        Node(E data, Node<E> next) {
            this.data = data;
            this.next = next;
        }
    }

    private Node<E> head;       // ë¨¸ë¦¬ í¬ì¸í„°(ë¨¸ë¦¬ ë…¸ë“œ ì°¸ì¡°)
    private Node<E> current;       // ì„ íƒ í¬ì¸í„°(ì„ íƒ ë…¸ë“œ ì°¸ì¡°)

    // ìƒì„±ì
    public LinkedList() {
        head = current = null;
    }

    public E search(E obj, Comparator<? super E> comparator) {
        Node<E> pointer = head;         // í˜„ì¬ ìŠ¤ìº” ì¤‘ì¸ ë…¸ë“œ

        while (pointer != null) {
            if (comparator.compare(obj, pointer.data) == 0) {   // ê²€ìƒ‰ ì„±ê³µ
                current = pointer;
                return pointer.data;
            }
            pointer = pointer.next;                             // ë‹¤ìŒ ë…¸ë“œë¥¼ ì„ íƒ
        }
        return null;                                            // ê²€ìƒ‰ ì‹¤íŒ¨
    }

    // ë¨¸ë¦¬ì— ë…¸ë“œ ì‚½ì…
    public void addFirst(E obj) {
        Node<E> pointer = head;
        head = current = new Node<E>(obj, pointer);
    }

    // ê¼¬ë¦¬ì— ë…¸ë“œ ì‚½ì…
    public void addLast(E obj) {
        if (head == null) {         // ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì–´ ìˆìœ¼ë©´
            addFirst(obj);          // ë¨¸ë¦¬ì— ì‚½ì…
        } else {
            Node<E> pointer = head;
            while (pointer.next != null) {
                pointer = pointer.next;
            }
            pointer.next = current = new Node<>(obj, null);
        }
    }

    // ë¨¸ë¦¬ ë…¸ë“œë¥¼ ì‚­ì œ
    public void removeFirst() {
        if (head != null) {             // ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì–´ ìˆì§€ ì•Šìœ¼ë©´
            head = current = head.next;
        }
    }

    public void removeLast() {
        if (head != null) {             // ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì–´ ìˆì§€ ì•Šìœ¼ë©´
            if (head.next == null) {    // ë…¸ë“œê°€ í•˜ë‚˜ë§Œ ìˆìœ¼ë©´
                removeFirst();
            } else {
                Node<E> pointer = head; // ìŠ¤ìº” ì¤‘ì¸ ë…¸ë“œ
                Node<E> pre = head;     // ìŠ¤íƒ  ì¤‘ì¸ ë…¸ë“œì˜ ì•ìª½ ë…¸ë“œ

                while (pointer.next != null) {
                    pre = pointer;
                    pointer = pointer.next;
                }
                pre.next = null;        // preëŠ” ì‚­ì œ í›„ì˜ ê¼¬ë¦¬ ë…¸ë“œ
                current = pre;
            }
        }
    }

    public void remove(Node p) {
        if (head != null) {
            if (p == head) {        // pê°€ ë¨¸ë¦¬ ë…¸ë“œë©´
                removeFirst();      // ë¨¸ë¦¬ ë…¸ë“œë¥¼ ì‚­ì œ
            } else {
                Node<E> pointer = head;

                while (pointer.next != p) {
                    pointer = pointer.next;
                    if (pointer == null) return;        // pê°€ ë¦¬ìŠ¤íŠ¸ì— ì—†ìŒ
                }
                pointer.next = p.next;
                current = pointer;
            }
        }
    }

    // ì„ íƒ ë…¸ë“œë¥¼ ì‚­ì œ
    public void removeCurrentNode() {
        remove(current);
    }

    // ëª¨ë“  ë…¸ë“œë¥¼ ì‚­ì œ
    public void clear() {
        while (head != null) {      // ë…¸ë“œì— ì•„ë¬´ê²ƒë„ ì—†ì„ ë•Œê¹Œì§€
            removeFirst();          // ë¨¸ë¦¬ ë…¸ë“œë¥¼ ì‚­ì œ
        }
        current = null;
    }

    // ì„ íƒ ë…¸ë“œë¥¼ í•˜ë‚˜ ë’¤ìª½ìœ¼ë¡œ ì§„í–‰
    public boolean next() {
        if (current == null || current.next == null) {
            return false;            // ì§„í–‰í•  ìˆ˜ ì—†ìŒ
        }
        current = current.next;
        return true;
    }

    // ì„ íƒ ë…¸ë“œë¥¼ ì¶œë ¥
    public void printCurrentNode() {
        if (current == null) System.out.println("ì„ íƒí•œ ë…¸ë“œê°€ ì—†ìŠµë‹ˆë‹¤");
        else System.out.println(current.data);
    }

    // ëª¨ë“  ë…¸ë“œë¥¼ ì¶œë ¥
    public void dump() {
        Node<E> pointer = head;

        while (pointer != null) {
            System.out.println(pointer.data);
            pointer = pointer.next;
        }
    }
}
```

* LinkedListTester

```java

import java.util.Comparator;
import java.util.Date;
import java.util.Scanner;

public class LinkedListTester {

    static Scanner sc = new Scanner(System.in);

    // ë°ì´í„°(íšŒì›ë²ˆí˜¸ + ì´ë¦„)
    static class Data {
        static final int NO = 1;        // ë²ˆí˜¸ ì…ë ¥ë°›ê¸°
        static final int NAME = 2;      // ì´ë¦„ ì…ë ¥ë°›ê¸°

        private Integer no;     // íšŒì›ë²ˆí˜¸
        private String name;    // ì´ë¦„

        // ë¬¸ìì—´ ì¶œë ¥ì„ ë°˜í™˜
        public String toString() {
            return "(" + no + ") " + name;
        }

        // ë°ì´í„° ì…ë ¥ë°›ê¸°
        void scanData(String guide, int sw) {
            System.out.println(guide + "í•  ë°ì´í„°ë¥¼ ì…ë ¥í•˜ì„¸ìš”");

            if ((sw & NO) == NO) {              // ë¹„íŠ¸ ì—°ì‚°ì„ ì‚¬ìš©í•˜ì—¬ ì—¬ëŸ¬ ì˜µì…˜ì„ ë™ì‹œì— ì²´í¬í•˜ëŠ” ëª©ì ìœ¼ë¡œ ì‚¬ìš©
                System.out.print("ë²ˆí˜¸: ");
                no = sc.nextInt();
            }
            if ((sw & NAME) == NAME) {
                System.out.print("ì´ë¦„: ");
                name = sc.next();
            }
        }

        // íšŒì›ë²ˆí˜¸ë¡œ ìˆœì„œë¥¼ ì •í•˜ëŠ” comparator
        public static final Comparator<Data> NO_ORDER = new NoOrderComparator();
        private static class NoOrderComparator implements Comparator<Data> {
            public int compare(Data d1, Data d2) {
                return d1.no.compareTo(d2.no);
//                return (d1.no > d2.no) ? 1 : (d1.no < d2.no) ? -1 : 0;
            }
        }

        // ì´ë¦„ìœ¼ë¡œ ìˆœì„œë¥¼ ì •í•˜ëŠ” comparator
        public static final Comparator<Data> NAME_ORDER = new NameOrderComparator();
        private static class NameOrderComparator implements Comparator<Data> {
            public int compare(Data d1, Data d2) {
                return d1.name.compareTo(d2.name);
            }
        }
    }

    // ë©”ë‰´ ì—´ê±°í˜•
    enum Menu {
        ADD_FIRST("ë¨¸ë¦¬ì— ë…¸ë“œë¥¼ ì‚½ì…"),
        ADD_LAST("ê¼¬ë¦¬ì— ë…¸ë“œë¥¼ ì‚½ì…"),
        RMV_FIRST("ë¨¸ë¦¬ ë…¸ë“œë¥¼ ì‚­ì œ"),
        RMV_LAST("ê¼¬ë¦¬ ë…¸ë“œë¥¼ ì‚­ì œ"),
        RMV_CRNT("ì„ íƒ ë…¸ë“œë¥¼ ì‚­ì œ"),
        CLEAR("ëª¨ë“  ë…¸ë“œë¥¼ ì‚­ì œ"),
        SEARCH_NO("ë²ˆí˜¸ë¡œ ê²€ìƒ‰"),
        SEARCH_NAME("ì´ë¦„ìœ¼ë¡œ ê²€ìƒ‰"),
        NEXT("ì„ íƒ ë…¸ë“œë¥¼ í•˜ë‚˜ ë’¤ìª½ìœ¼ë¡œ ì§„í–‰"),
        PRINT_CRNT("ì„ íƒ ë…¸ë“œë¥¼ ì¶œë ¥"),
        DUMP("ëª¨ë“  ë…¸ë“œë¥¼ ì¶œë ¥"),
        TERMINATE("ì¢…ë£Œ");
        
        private final String message;       // ì¶œë ¥í•  ë¬¸ìì—´

        static Menu MenuAt(int index) {     // ìˆœì„œê°€ indexì¸ ì—´ê±°ë¥¼ ë°˜í™˜
            for (Menu m : Menu.values()) {
                if (m.ordinal() == index) {     // ordinal() : Enum íƒ€ì…ì—ì„œ ê° ìƒìˆ˜(Constant)ê°€ ì •ì˜ëœ ìˆœì„œë¥¼ ë°˜í™˜í•˜ëŠ” ë©”ì„œë“œ
                    return m;
                }
            }
            return null;
        }
        // ìƒì„±ì
        Menu(String string) {
            message = string;
        }
        // ì¶œë ¥í•  ë¬¸ìì—´ì„ ë°˜í™˜
        String getMessage() {
            return message;
        }
    }

    // ë©”ë‰´ ì„ íƒ
    static Menu SelectMenu() {
        int key = 0;
        do {
            for (Menu m : Menu.values()) {
                System.out.printf("(%d) %s ", m.ordinal(), m.getMessage());
                if ((m.ordinal() % 3) == 2 && m.ordinal() != Menu.TERMINATE.ordinal()) {
                    System.out.println();
                }
            }
            System.out.print(" : ");
            key = sc.nextInt();
        } while (key < Menu.ADD_FIRST.ordinal() || key > Menu.TERMINATE.ordinal());
        return Menu.MenuAt(key);
    }

    public static void main(String[] args) {
        Menu menu;                // ë©”ë‰´
        Data data;                // ì¶”ê°€ìš© ë°ì´í„° ì°¸ì¡°
        Data ptr;                 // ê²€ìƒ‰ìš© ë°ì´í„° ì°¸ì¡°
        Data temp = new Data();   // ì…ë ¥ìš© ë°ì´í„°

        LinkedList<Data> list = new LinkedList<>();     // ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±

        do {
            switch (menu = SelectMenu()) {

                case ADD_FIRST:             // ë¨¸ë¦¬ì— ë…¸ë“œë¥¼ ì‚½ì…
                    data = new Data();
                    data.scanData("ë¨¸ë¦¬ì— ì‚½ì…", Data.NO | Data.NAME);
                    list.addFirst(data);
                    break;

                case ADD_LAST:              // ê¼¬ë¦¬ì— ë…¸ë“œë¥¼ ì‚½ì…
                    data = new Data();
                    data.scanData("ê¼¬ë¦¬ì— ì‚½ì…", Data.NO | Data.NAME);
                    list.addLast(data);
                    break;

                case RMV_FIRST:             // ë¨¸ë¦¬ ë…¸ë“œë¥¼ ì‚­ì œ
                    list.removeFirst();
                    break;

                case RMV_LAST:              // ê¼¬ë¦¬ ë…¸ë“œë¥¼ ì‚­ì œ
                    list.removeLast();
                    break;

                case RMV_CRNT:              // ì„ íƒ ë…¸ë“œë¥¼ ì‚­ì œ
                    list.removeCurrentNode();
                    break;

                case SEARCH_NO:             // íšŒì› ë²ˆí˜¸ë¡œ ê²€ìƒ‰
                    temp.scanData("ê²€ìƒ‰", Data.NO);
                    ptr = list.search(temp, Data.NO_ORDER);
                    if (ptr == null) System.out.println("ê·¸ ë²ˆí˜¸ì˜ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
                    else System.out.println("ê²€ìƒ‰ ì„±ê³µ: " + ptr);
                    break;

                case SEARCH_NAME:           // ì´ë¦„ìœ¼ë¡œ ê²€ìƒ‰
                    temp.scanData("ê²€ìƒ‰", Data.NAME);
                    ptr = list.search(temp, Data.NAME_ORDER);
                    if (ptr == null) System.out.println("ê·¸ ì´ë¦„ì˜ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
                    else System.out.println("ê²€ìƒ‰ ì„±ê³µ: " + ptr);
                    break;

                case NEXT:                  // ì„ íƒ ë…¸ë“œë¥¼ í•˜ë‚˜ ë’¤ìª½ìœ¼ë¡œ ì§„í–‰
                    list.next();
                    break;

                case PRINT_CRNT:            // ì„ íƒ ë…¸ë“œì˜ ë°ì´í„°ë¥¼ ì¶œë ¥
                    list.printCurrentNode();
                    break;

                case DUMP:                  // ëª¨ë“  ë…¸ë“œë¥¼ ë¦¬ìŠ¤íŠ¸ ìˆœì„œëŒ€ë¡œ ì¶œë ¥
                    list.dump();
                    break;

                case CLEAR:                 // ëª¨ë“  ë…¸ë“œë¥¼ ê²€ìƒ‰
                    list.clear();
                    break;
            }
        } while (menu != Menu.TERMINATE);
    }
}

```